<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ray Tracing - Interactive Viewer (Standalone)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
        }
        
        #container {
            display: flex;
            height: 100vh;
        }
        
        #canvas-container {
            flex: 1;
            position: relative;
            background: #000;
        }
        
        #canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        #controls {
            width: 300px;
            background: #2a2a2a;
            padding: 20px;
            overflow-y: auto;
            border-left: 1px solid #444;
        }
        
        .control-group {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #444;
        }
        
        .control-group h3 {
            margin-bottom: 10px;
            color: #4a9eff;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #aaa;
        }
        
        input[type="range"] {
            width: 100%;
            margin-bottom: 10px;
        }
        
        input[type="number"] {
            width: 100%;
            padding: 5px;
            background: #333;
            border: 1px solid #555;
            color: #e0e0e0;
            border-radius: 3px;
        }
        
        button {
            width: 100%;
            padding: 10px;
            background: #4a9eff;
            border: none;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 10px;
            transition: background 0.2s;
        }
        
        button:hover {
            background: #5aaeff;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
        
        .note {
            background: #333;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            font-size: 11px;
            color: #aaa;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
            <div id="info">
                <div>Mode: <span id="mode-display">Three.js Preview</span></div>
                <div>FPS: <span id="fps">0</span></div>
            </div>
        </div>
        <div id="controls">
            <div class="note">
                <strong>Standalone Mode</strong><br>
                Open this file directly in a browser. For full features, use <code>npm run dev</code>.
            </div>
            
            <div class="control-group">
                <h3>Camera</h3>
                <label>Rotation X: <span id="rot-x-val">0</span>°</label>
                <input type="range" id="rot-x" min="-180" max="180" value="0">
                
                <label>Rotation Y: <span id="rot-y-val">0</span>°</label>
                <input type="range" id="rot-y" min="-180" max="180" value="0">
                
                <label>Distance: <span id="dist-val">5.0</span></label>
                <input type="range" id="distance" min="2" max="15" step="0.1" value="5.0">
            </div>
            
            <div class="control-group">
                <h3>Scene Info</h3>
                <div style="font-size: 11px; color: #aaa; line-height: 1.6;">
                    <div>• 4 Mirrors</div>
                    <div>• 1 Candle (glowing)</div>
                    <div>• Infinite Reflections</div>
                    <div>• Mouse: Rotate</div>
                    <div>• Wheel: Zoom</div>
                </div>
            </div>
            
            <button id="reload-scene">Reload Scene</button>
        </div>
    </div>
    
    <!-- Load Three.js from CDN -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    
    <script type="module">
        // Simple Three.js renderer for standalone mode
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        console.log('Three.js loaded successfully');
        
        const canvas = document.getElementById('canvas');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        
        const camera = new THREE.PerspectiveCamera(60, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
        camera.position.set(0, 1.5, 5);
        
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        
        const controls = new OrbitControls(camera, canvas);
        controls.target.set(0, 1.5, 0);
        controls.enableDamping = true;
        
        // Load scene - embedded scene data (works without server)
        let sceneData = {
            camera: { position: [2.5, 1.8, 2.5], look_at: [0.0, 1.5, -2.0], fov: 60.0 },
            room: { size: [8.0, 6.0, 8.0], center: [0.0, 3.0, 0.0], wall_color: [0.8, 0.8, 0.9], floor_color: [0.6, 0.5, 0.4], ceiling_color: [0.9, 0.9, 0.95] },
            light: { position: [1.5, 4.5, -1.5], radius: 0.25, intensity: [20.0, 18.0, 16.0], color: [1.0, 0.95, 0.9] },
            mirrors: [
                { position: [0.0, 1.5, -3.9], normal: [0.0, 0.0, 1.0], size: [3.0, 3.5], reflectivity: 0.95 },
                { position: [3.9, 1.5, 0.0], normal: [-1.0, 0.0, 0.0], size: [2.0, 3.0], reflectivity: 0.95 },
                { position: [-3.9, 1.5, 0.0], normal: [1.0, 0.0, 0.0], size: [2.0, 3.0], reflectivity: 0.95 },
                { position: [0.0, 1.5, 3.9], normal: [0.0, 0.0, -1.0], size: [2.0, 3.0], reflectivity: 0.95 }
            ],
            candles: [
                { position: [0.0, 0.0, -2.0], height: 1.5, radius: 0.2, flame_intensity: [8.0, 6.0, 4.0], wax_color: [0.9, 0.9, 0.95] }
            ],
            render: { width: 800, height: 600, samples: 1, max_bounces: 50 }
        };
        
        async function loadScene() {
            // Try to load from file, fallback to embedded
            try {
                const response = await fetch('scene.json');
                if (response.ok) {
                    sceneData = await response.json();
                    console.log('Loaded scene.json from file');
                }
            } catch (e) {
                console.log('Using embedded scene data');
            }
            buildScene();
        }
        
        function buildScene() {
            while(scene.children.length > 0) scene.remove(scene.children[0]);
            
            const room = sceneData.room;
            const roomSize = room.size;
            const roomCenter = room.center;
            
            // Floor
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(roomSize[0], roomSize[2]),
                new THREE.MeshStandardMaterial({ color: new THREE.Color(...room.floor_color), roughness: 0.8 })
            );
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(roomCenter[0], roomCenter[1] - roomSize[1]/2, roomCenter[2]);
            scene.add(floor);
            
            // Light
            const light = sceneData.light;
            const lightPos = light.position;
            const pointLight = new THREE.PointLight(new THREE.Color(...light.color), 5, 50);
            pointLight.position.set(lightPos[0], lightPos[1], lightPos[2]);
            scene.add(pointLight);
            
            const lightMesh = new THREE.Mesh(
                new THREE.SphereGeometry(light.radius, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0xffffaa, emissive: 0xffffaa })
            );
            lightMesh.position.set(lightPos[0], lightPos[1], lightPos[2]);
            scene.add(lightMesh);
            
            // Mirrors
            sceneData.mirrors.forEach(mirror => {
                const mirrorMesh = new THREE.Mesh(
                    new THREE.PlaneGeometry(mirror.size[0], mirror.size[1]),
                    new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.9, roughness: 0.1 })
                );
                mirrorMesh.position.set(...mirror.position);
                const normal = new THREE.Vector3(...mirror.normal);
                mirrorMesh.lookAt(
                    mirror.position[0] + normal.x,
                    mirror.position[1] + normal.y,
                    mirror.position[2] + normal.z
                );
                scene.add(mirrorMesh);
            });
            
        // Candles
        if (sceneData.candles) {
            sceneData.candles.forEach(candle => {
                const pos = candle.position;
                const height = candle.height || 1.5;
                const radius = candle.radius || 0.2;
                const waxColor = new THREE.Color(...(candle.wax_color || [0.9, 0.9, 0.95]));
                
                // Candle body (cylinder)
                const candleBody = new THREE.Mesh(
                    new THREE.CylinderGeometry(radius, radius, height, 16),
                    new THREE.MeshStandardMaterial({ color: waxColor, roughness: 0.8 })
                );
                candleBody.position.set(pos[0], pos[1] + height * 0.5, pos[2]);
                candleBody.castShadow = true;
                scene.add(candleBody);
                
                // Flame (emissive sphere)
                const flameIntensity = candle.flame_intensity || [8, 6, 4];
                const flameColor = new THREE.Color(flameIntensity[0] / 10, flameIntensity[1] / 10, flameIntensity[2] / 10);
                const flame = new THREE.Mesh(
                    new THREE.SphereGeometry(0.12, 16, 16),
                    new THREE.MeshBasicMaterial({ 
                        color: 0xffaa44,
                        emissive: 0xffaa44,
                        emissiveIntensity: 2.0
                    })
                );
                flame.position.set(pos[0], pos[1] + height + 0.15, pos[2]);
                
                // Point light from flame
                const flameLight = new THREE.PointLight(
                    new THREE.Color(1.0, 0.7, 0.5),
                    Math.max(...flameIntensity),
                    10
                );
                flameLight.position.set(pos[0], pos[1] + height + 0.15, pos[2]);
                flameLight.castShadow = true;
                scene.add(flameLight);
                scene.add(flame);
            });
        }
        
        // Human models (backward compatibility)
        if (sceneData.human_models) {
            sceneData.human_models.forEach(human => {
                const group = new THREE.Group();
                group.position.set(...human.position);
                
                const color = new THREE.Color(...human.color);
                
                // Torso
                const torso = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.25, 0.25, 0.8, 16),
                    new THREE.MeshStandardMaterial({ color, roughness: 0.7 })
                );
                torso.position.y = 0.4;
                group.add(torso);
                
                // Head
                const head = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 16, 16),
                    new THREE.MeshStandardMaterial({ color, roughness: 0.7 })
                );
                head.position.y = 1.1;
                group.add(head);
                
                scene.add(group);
            });
        }
        
        scene.add(new THREE.AmbientLight(0x404040, 0.3));
        }
        
        // Controls
        const humanRotControl = document.getElementById('human-rotation');
        if (humanRotControl) {
            humanRotControl.addEventListener('input', (e) => {
                document.getElementById('human-rot-val').textContent = e.target.value;
                const angle = parseFloat(e.target.value) * Math.PI / 180;
                scene.children.forEach(child => {
                    if (child.type === 'Group') child.rotation.y = angle;
                });
            });
        }
        
        document.getElementById('reload-scene').addEventListener('click', loadScene);
        
        // FPS counter
        let lastTime = performance.now();
        let frameCount = 0;
        function updateFPS() {
            frameCount++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastTime = now;
            }
        }
        
        // Render loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            updateFPS();
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        });
        
        loadScene();
        animate();
    </script>
</body>
</html>

