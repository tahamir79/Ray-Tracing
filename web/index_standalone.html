<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ray Tracing - Interactive Viewer (Standalone)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
        }
        
        #container {
            display: flex;
            height: 100vh;
        }
        
        #canvas-container {
            flex: 1;
            position: relative;
            background: #000;
        }
        
        #canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        #controls {
            width: 300px;
            background: #2a2a2a;
            padding: 20px;
            overflow-y: auto;
            border-left: 1px solid #444;
        }
        
        .control-group {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #444;
        }
        
        .control-group h3 {
            margin-bottom: 10px;
            color: #4a9eff;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #aaa;
        }
        
        input[type="range"] {
            width: 100%;
            margin-bottom: 10px;
        }
        
        input[type="number"] {
            width: 100%;
            padding: 5px;
            background: #333;
            border: 1px solid #555;
            color: #e0e0e0;
            border-radius: 3px;
        }
        
        button {
            width: 100%;
            padding: 10px;
            background: #4a9eff;
            border: none;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 10px;
            transition: background 0.2s;
        }
        
        button:hover {
            background: #5aaeff;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
        
        .note {
            background: #333;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            font-size: 11px;
            color: #aaa;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
            <div id="info">
                <div>Mode: <span id="mode-display">Three.js Preview</span></div>
                <div>FPS: <span id="fps">0</span></div>
            </div>
        </div>
        <div id="controls">
            <div class="note">
                <strong>Standalone Mode</strong><br>
                Open this file directly in a browser. For full features, use <code>npm run dev</code>.
            </div>
            
            <div class="control-group">
                <h3>Controls</h3>
                <div style="font-size: 11px; color: #aaa; line-height: 1.8;">
                    <div style="color: #4a9eff; margin-bottom: 5px;"><strong>Move Candle:</strong></div>
                    <div><strong>W/A/S/D</strong> - Move candle</div>
                    <div><strong>Q/E</strong> - Move up/down</div>
                    <div><strong>Shift</strong> - Speed boost</div>
                    <div style="color: #4a9eff; margin-top: 8px;"><strong>Camera:</strong></div>
                    <div><strong>Mouse</strong> - Look around</div>
                    <div><strong>Wheel</strong> - Zoom</div>
                </div>
            </div>
            
            <div class="control-group">
                <h3>Camera</h3>
                <label>Rotation X: <span id="rot-x-val">0</span>°</label>
                <input type="range" id="rot-x" min="-180" max="180" value="0">
                
                <label>Rotation Y: <span id="rot-y-val">0</span>°</label>
                <input type="range" id="rot-y" min="-180" max="180" value="0">
                
                <label>Distance: <span id="dist-val">5.0</span></label>
                <input type="range" id="distance" min="2" max="15" step="0.1" value="5.0">
            </div>
            
            <div class="control-group">
                <h3>Scene Info</h3>
                <div style="font-size: 11px; color: #aaa; line-height: 1.6;">
                    <div>• 4 Mirrors</div>
                    <div>• 1 Candle (glowing)</div>
                    <div>• Infinite Reflections</div>
                    <div>• Mouse: Rotate</div>
                    <div>• Wheel: Zoom</div>
                </div>
            </div>
            
            <button id="reload-scene">Reload Scene</button>
        </div>
    </div>
    
    <!-- Load Three.js from CDN -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    
    <script type="module">
        // Simple Three.js renderer for standalone mode
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        console.log('Three.js loaded successfully');
        
        const canvas = document.getElementById('canvas');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        
        const camera = new THREE.PerspectiveCamera(60, canvas.clientWidth / canvas.clientHeight, 0.1, 2000);
        camera.position.set(0, 3, 10);  // Adjusted for bigger room
        
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        
        // Create render targets for recursive mirror reflections (fractal effect)
        const mirrorRenderTargets = [];
        const maxReflectionDepth = 10;  // Deep recursion for fractal effect
        
        for (let i = 0; i < maxReflectionDepth; i++) {
            const rt = new THREE.WebGLRenderTarget(canvas.clientWidth, canvas.clientHeight, {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat
            });
            mirrorRenderTargets.push(rt);
        }
        
        const controls = new OrbitControls(camera, canvas);
        controls.target.set(0, 6, 0);  // Center of bigger room
        controls.enableDamping = true;
        
        // Keyboard movement state for candle
        const keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            q: false,  // Up
            e: false,  // Down
            shift: false,  // Speed boost
            space: false  // Jump
        };
        
        // Movement speed
        let moveSpeed = 0.05;
        const baseSpeed = 0.05;
        const fastSpeed = 0.15;
        
        // Physics simulation for candle
        const candlePhysics = {
            velocity: new THREE.Vector3(0, 0, 0),  // Current velocity
            gravity: -0.02,  // Gravity acceleration
            jumpPower: 0.35,  // Initial jump velocity
            jumpMultiplier: 1.25,  // Distance multiplier for jump
            onGround: true,
            groundY: null  // Will be set when candle is created
        };
        
        // Store candle objects for movement
        let candleObjects = [];
        
        // Load scene - embedded scene data (works without server)
            let sceneData = {
            camera: { position: [2.5, 1.8, 2.5], look_at: [0.0, 1.5, -2.0], fov: 60.0 },
            room: { size: [16.0, 12.0, 16.0], center: [0.0, 6.0, 0.0], wall_color: [0.8, 0.8, 0.9], floor_color: [0.6, 0.5, 0.4], ceiling_color: [0.9, 0.9, 0.95] },
            light: { position: [0.0, 11.5, 0.0], radius: 0.25, intensity: [40.0, 36.0, 32.0], color: [1.0, 0.95, 0.9] },
            mirrors: [
                { position: [0.0, 6.0, -7.9], normal: [0.0, 0.0, 1.0], size: [16.0, 12.0], reflectivity: 0.95 },
                { position: [7.9, 6.0, 0.0], normal: [-1.0, 0.0, 0.0], size: [16.0, 12.0], reflectivity: 0.95 },
                { position: [-7.9, 6.0, 0.0], normal: [1.0, 0.0, 0.0], size: [16.0, 12.0], reflectivity: 0.95 },
                { position: [0.0, 6.0, 7.9], normal: [0.0, 0.0, -1.0], size: [16.0, 12.0], reflectivity: 0.95 }
            ],
            candles: [
                { position: [0.0, 0.0, -2.0], height: 1.5, radius: 0.2, flame_intensity: [8.0, 6.0, 4.0], wax_color: [0.9, 0.9, 0.95] }
            ],
            render: { width: 800, height: 600, samples: 1, max_bounces: 50 }
        };
        
        async function loadScene() {
            // Try to load from file, fallback to embedded
            try {
                const response = await fetch('scene.json');
                if (response.ok) {
                    sceneData = await response.json();
                    console.log('Loaded scene.json from file');
                }
            } catch (e) {
                console.log('Using embedded scene data');
            }
            buildScene();
        }
        
        function buildScene() {
            while(scene.children.length > 0) scene.remove(scene.children[0]);
            
            const room = sceneData.room;
            const roomSize = room.size;
            const roomCenter = room.center;
            
            // Floor
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(roomSize[0], roomSize[2]),
                new THREE.MeshStandardMaterial({ color: new THREE.Color(...room.floor_color), roughness: 0.8 })
            );
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(roomCenter[0], roomCenter[1] - roomSize[1]/2, roomCenter[2]);
            floor.receiveShadow = true;
            scene.add(floor);
            
            // Matte Ceiling
            const ceiling = new THREE.Mesh(
                new THREE.PlaneGeometry(roomSize[0], roomSize[2]),
                new THREE.MeshStandardMaterial({ 
                    color: new THREE.Color(...room.ceiling_color), 
                    roughness: 1.0,  // Fully matte
                    metalness: 0.0    // Non-metallic
                })
            );
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.set(roomCenter[0], roomCenter[1] + roomSize[1]/2, roomCenter[2]);
            ceiling.receiveShadow = true;
            scene.add(ceiling);
            
            // Ceiling Light - dangling from center with chain
            const light = sceneData.light;
            const baseLightPos = new THREE.Vector3(...light.position);
            const lightIntensity = Math.max(...(light.intensity || [20, 18, 16]));
            
            // Create lamp group for dangling effect
            const lampGroup = new THREE.Group();
            lampGroup.position.copy(baseLightPos);
            scene.add(lampGroup);
            
            // Lamp chain/cord (cylinder hanging down)
            const chainLength = 0.8;
            const chainGeometry = new THREE.CylinderGeometry(0.02, 0.02, chainLength, 8);
            const chainMaterial = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.8, roughness: 0.2 });
            const chain = new THREE.Mesh(chainGeometry, chainMaterial);
            chain.position.set(0, -chainLength * 0.5, 0);
            lampGroup.add(chain);
            
            // Main point light (very bright) - attached to lamp group
            const pointLight = new THREE.PointLight(
                new THREE.Color(...light.color), 
                lightIntensity * 2,  // Much brighter
                100  // Larger range for bigger room
            );
            pointLight.position.set(0, -chainLength, 0);
            lampGroup.add(pointLight);
            
            // Create realistic lamp shape for inner core
            const lampRadius = light.radius;
            const lampHeight = lampRadius * 1.8;  // Slightly elongated bulb shape
            
            // Inner lamp bulb (realistic light bulb shape)
            const lampShape = new THREE.ConeGeometry(lampRadius * 0.6, lampHeight * 0.4, 8, 1, true);
            const lampMesh = new THREE.Mesh(
                lampShape,
                new THREE.MeshBasicMaterial({ 
                    color: 0xffffaa,
                    emissive: 0xffffaa,
                    emissiveIntensity: 3.0,
                    side: THREE.DoubleSide
                })
            );
            lampMesh.position.set(0, -chainLength, 0);
            lampMesh.rotation.x = Math.PI;  // Flip to point down
            lampGroup.add(lampMesh);
            
            // Ultra-fine smooth spectrum glow - shorter range with faster decay
            const numLayers = 60;  // Many more layers for ultra-smooth gradient
            const maxRadiusMultiplier = 2.0;  // Shorter range (was 4, now 2)
            for (let i = 0; i < numLayers; i++) {
                const t = i / (numLayers - 1);  // 0 to 1
                const radius = light.radius * (1 + t * maxRadiusMultiplier);  // Shorter expansion
                
                // Color spectrum: bright yellow/white core -> warm yellow -> dim yellow -> transparent
                // Very smooth linear interpolation
                const r = Math.max(0, Math.min(255, 255 - t * 30));  // 255 -> 225
                const g = Math.max(0, Math.min(255, 255 - t * 50));  // 255 -> 205
                const b = Math.max(0, Math.min(255, 200 - t * 100)); // 200 -> 100
                const color = (r << 16) | (g << 8) | b;
                
                // Opacity: 1.0 at core -> 0.0 at edge (faster exponential decay)
                // Steeper falloff curve for more noticeable decay
                const opacity = Math.pow(1 - t, 4.0);  // Steeper exponential fade (was 2.5)
                
                const glowMesh = new THREE.Mesh(
                    new THREE.SphereGeometry(radius, 32, 32),
                    new THREE.MeshBasicMaterial({ 
                        color: color,
                        emissive: color,
                        emissiveIntensity: opacity * 2,
                        transparent: true,
                        opacity: opacity,
                        side: THREE.DoubleSide,
                        depthWrite: false  // Prevent z-fighting between layers
                    })
                );
                // Position glow relative to lamp group
                glowMesh.position.set(0, -chainLength, 0);
                lampGroup.add(glowMesh);
            }
            
            // Mirrors - make them cover full walls
            sceneData.mirrors.forEach(mirror => {
                // Use full room dimensions for mirrors
                const roomSize = room.size;
                let mirrorWidth, mirrorHeight;
                
                // Determine mirror size based on wall orientation
                if (Math.abs(mirror.normal[0]) > 0.5) {
                    // Left/Right walls - use depth and height
                    mirrorWidth = roomSize[2];  // depth
                    mirrorHeight = roomSize[1]; // height
                } else {
                    // Front/Back walls - use width and height
                    mirrorWidth = roomSize[0];  // width
                    mirrorHeight = roomSize[1]; // height
                }
                
                const mirrorMesh = new THREE.Mesh(
                    new THREE.PlaneGeometry(mirrorWidth, mirrorHeight),
                    new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.9, roughness: 0.1 })
                );
                // Position at room center height
                mirrorMesh.position.set(mirror.position[0], roomCenter[1], mirror.position[2]);
                const normal = new THREE.Vector3(...mirror.normal);
                mirrorMesh.lookAt(
                    mirror.position[0] + normal.x,
                    roomCenter[1] + normal.y,
                    mirror.position[2] + normal.z
                );
                scene.add(mirrorMesh);
            });
            
        // Candles
        candleObjects = [];  // Reset candle objects array
        if (sceneData.candles) {
            sceneData.candles.forEach((candle, index) => {
                const pos = candle.position;
                const height = candle.height || 1.5;
                const radius = candle.radius || 0.2;
                const waxColor = new THREE.Color(...(candle.wax_color || [0.9, 0.9, 0.95]));
                
                // Create a group for the candle (so we can move it as one unit)
                const candleGroup = new THREE.Group();
                candleGroup.userData.originalY = pos[1];  // Store original Y position
                
                // Candle body (cylinder)
                const candleBody = new THREE.Mesh(
                    new THREE.CylinderGeometry(radius, radius, height, 16),
                    new THREE.MeshStandardMaterial({ color: waxColor, roughness: 0.8 })
                );
                candleBody.position.set(0, height * 0.5, 0);
                candleBody.castShadow = true;
                candleGroup.add(candleBody);
                
                // Flame with smooth spectrum halo
                const flameIntensity = candle.flame_intensity || [25, 20, 15];
                const maxIntensity = Math.max(...flameIntensity);
                
                // Smooth spectrum glow - many layers with gradual color/opacity transition
                const numLayers = 25;  // More layers for smoother transition
                const baseRadius = 0.12;
                
                for (let i = 0; i < numLayers; i++) {
                    const t = i / (numLayers - 1);  // 0 to 1
                    const radius = baseRadius * (1 + t * 4);  // Expand from core to 5x radius
                    
                    // Color spectrum: bright orange/yellow core -> orange -> red-orange -> dark red -> transparent
                    // Smooth transition through the spectrum
                    let r, g, b;
                    if (t < 0.3) {
                        // Core: Bright orange/yellow (0xffaa44)
                        const localT = t / 0.3;
                        r = 255 - localT * 10;  // 255 -> 245
                        g = 170 - localT * 20;  // 170 -> 150
                        b = 68 - localT * 10;   // 68 -> 58
                    } else if (t < 0.6) {
                        // Middle: Orange to red-orange
                        const localT = (t - 0.3) / 0.3;
                        r = 245 - localT * 30;  // 245 -> 215
                        g = 150 - localT * 40;  // 150 -> 110
                        b = 58 - localT * 20;   // 58 -> 38
                    } else {
                        // Outer: Red-orange to dark red/transparent
                        const localT = (t - 0.6) / 0.4;
                        r = 215 - localT * 100; // 215 -> 115
                        g = 110 - localT * 80;  // 110 -> 30
                        b = 38 - localT * 30;   // 38 -> 8
                    }
                    
                    const color = (Math.max(0, Math.min(255, r)) << 16) | 
                                  (Math.max(0, Math.min(255, g)) << 8) | 
                                  Math.max(0, Math.min(255, b));
                    
                    // Opacity: 1.0 at core -> 0.0 at edge (faster exponential decay)
                    // Steeper falloff curve for more noticeable decay
                    const opacity = Math.pow(1 - t, 4.5);  // Steeper exponential fade (was 2.2)
                    
                    const flameGlow = new THREE.Mesh(
                        new THREE.SphereGeometry(radius, 32, 32),
                        new THREE.MeshBasicMaterial({ 
                            color: color,
                            emissive: color,
                            emissiveIntensity: opacity * 3,
                            transparent: true,
                            opacity: opacity,
                            side: THREE.DoubleSide
                        })
                    );
                    flameGlow.position.set(0, height + 0.15, 0);
                    candleGroup.add(flameGlow);
                }
                
                // Point light from flame (much brighter)
                const flameLight = new THREE.PointLight(
                    new THREE.Color(1.0, 0.75, 0.6),
                    maxIntensity * 1.5,  // Much brighter
                    15  // Larger range
                );
                flameLight.position.set(0, height + 0.15, 0);
                flameLight.castShadow = true;
                candleGroup.add(flameLight);
                
                // Set initial position
                candleGroup.position.set(pos[0], pos[1], pos[2]);
                scene.add(candleGroup);
                
                // Store candle group for movement (only first candle is movable)
                if (index === 0) {
                    candleGroup.userData.height = height;  // Store height for physics
                    candleObjects.push(candleGroup);
                    
                    // Initialize physics ground level
                    if (candlePhysics.groundY === null) {
                        candlePhysics.groundY = pos[1] - height * 0.5;  // Bottom of candle
                    }
                }
            });
        }
        
        // Human models (backward compatibility)
        if (sceneData.human_models) {
            sceneData.human_models.forEach(human => {
                const group = new THREE.Group();
                group.position.set(...human.position);
                
                const color = new THREE.Color(...human.color);
                
                // Torso
                const torso = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.25, 0.25, 0.8, 16),
                    new THREE.MeshStandardMaterial({ color, roughness: 0.7 })
                );
                torso.position.y = 0.4;
                group.add(torso);
                
                // Head
                const head = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 16, 16),
                    new THREE.MeshStandardMaterial({ color, roughness: 0.7 })
                );
                head.position.y = 1.1;
                group.add(head);
                
                scene.add(group);
            });
        }
        
        scene.add(new THREE.AmbientLight(0x404040, 0.3));
        }
        
        // Controls
        const humanRotControl = document.getElementById('human-rotation');
        if (humanRotControl) {
            humanRotControl.addEventListener('input', (e) => {
                document.getElementById('human-rot-val').textContent = e.target.value;
                const angle = parseFloat(e.target.value) * Math.PI / 180;
                scene.children.forEach(child => {
                    if (child.type === 'Group') child.rotation.y = angle;
                });
            });
        }
        
        document.getElementById('reload-scene').addEventListener('click', loadScene);
        
        // FPS counter
        let lastTime = performance.now();
        let frameCount = 0;
        function updateFPS() {
            frameCount++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastTime = now;
            }
        }
        
        // Keyboard event handlers
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (key === 'w') keys.w = true;
            if (key === 'a') keys.a = true;
            if (key === 's') keys.s = true;
            if (key === 'd') keys.d = true;
            if (key === 'q') keys.q = true;
            if (key === 'e') keys.e = true;
            if (e.key === 'Shift') keys.shift = true;
            if (e.key === ' ' || e.key === 'Spacebar') {
                e.preventDefault();  // Prevent page scroll
                keys.space = true;
            }
        });
        
        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (key === 'w') keys.w = false;
            if (key === 'a') keys.a = false;
            if (key === 's') keys.s = false;
            if (key === 'd') keys.d = false;
            if (key === 'q') keys.q = false;
            if (key === 'e') keys.e = false;
            if (e.key === 'Shift') keys.shift = false;
            if (e.key === ' ' || e.key === 'Spacebar') {
                keys.space = false;
            }
        });
        
        // Update candle movement with physics simulation
        function updateMovement() {
            if (candleObjects.length === 0) return;
            
            moveSpeed = keys.shift ? fastSpeed : baseSpeed;
            
            const candle = candleObjects[0];  // Move first candle
            const moveVector = new THREE.Vector3();
            
            // Get camera direction for relative movement
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0;  // Keep movement horizontal
            direction.normalize();
            
            // Right vector (perpendicular to forward)
            const right = new THREE.Vector3();
            right.crossVectors(direction, new THREE.Vector3(0, 1, 0)).normalize();
            
            // Forward/backward (relative to camera view)
            if (keys.w) moveVector.add(direction);
            if (keys.s) moveVector.sub(direction);
            
            // Left/right (relative to camera view)
            if (keys.a) moveVector.sub(right);
            if (keys.d) moveVector.add(right);
            
            // Up/down (world space) - only when not using physics jump
            if (keys.q && candlePhysics.onGround) moveVector.y += 1;
            if (keys.e && candlePhysics.onGround) moveVector.y -= 1;
            
            // Normalize and apply speed for horizontal movement
            if (moveVector.length() > 0) {
                moveVector.normalize();
                moveVector.multiplyScalar(moveSpeed);
                
                // Update horizontal velocity
                candlePhysics.velocity.x = moveVector.x;
                candlePhysics.velocity.z = moveVector.z;
            } else {
                // Apply friction to horizontal velocity
                candlePhysics.velocity.x *= 0.9;
                candlePhysics.velocity.z *= 0.9;
            }
            
            // Jump physics - space bar pressed
            if (keys.space && candlePhysics.onGround) {
                // Calculate jump velocity based on current movement direction
                const horizontalSpeed = Math.sqrt(
                    candlePhysics.velocity.x * candlePhysics.velocity.x + 
                    candlePhysics.velocity.z * candlePhysics.velocity.z
                );
                
                // Jump with 1.25x multiplier of current movement speed
                const jumpVelocity = candlePhysics.jumpPower * (1 + horizontalSpeed * candlePhysics.jumpMultiplier);
                candlePhysics.velocity.y = jumpVelocity;
                candlePhysics.onGround = false;
            }
            
            // Apply gravity to vertical velocity
            if (!candlePhysics.onGround) {
                candlePhysics.velocity.y += candlePhysics.gravity;
            }
            
            // Update candle position based on velocity
            candle.position.x += candlePhysics.velocity.x;
            candle.position.z += candlePhysics.velocity.z;
            candle.position.y += candlePhysics.velocity.y;
            
            // Ground collision detection
            if (candlePhysics.groundY !== null) {
                const candleHeight = candle.userData.height || 1.5;
                const candleBottom = candle.position.y - candleHeight * 0.5;
                
                if (candleBottom <= candlePhysics.groundY) {
                    candle.position.y = candlePhysics.groundY + candleHeight * 0.5;
                    candlePhysics.velocity.y = 0;
                    candlePhysics.onGround = true;
                } else {
                    candlePhysics.onGround = false;
                }
            }
            
            // Keep candle within room bounds
            const room = sceneData.room;
            const roomSize = room.size;
            const roomCenter = room.center;
            const roomBounds = roomSize[0] * 0.5 - 0.5;  // Half of room width minus margin
            const roomHeight = roomSize[1];
            
            candle.position.x = Math.max(-roomBounds, Math.min(roomBounds, candle.position.x));
            candle.position.z = Math.max(-roomBounds, Math.min(roomBounds, candle.position.z));
            candle.position.y = Math.max(
                candlePhysics.groundY !== null ? candlePhysics.groundY + (candle.userData.height || 1.5) * 0.5 : 0, 
                Math.min(roomHeight - 0.5, candle.position.y)
            );
        }
        
        // Recursive mirror reflection rendering
        function renderMirrorReflections() {
            const mirrorMeshes = scene.userData.mirrorMeshes || [];
            if (mirrorMeshes.length === 0) return;
            
            // Render recursive reflections for each mirror
            mirrorMeshes.forEach((mirrorMesh, mirrorIndex) => {
                const normal = mirrorMesh.userData.normal;
                const mirrorPos = mirrorMesh.position;
                
                // Calculate reflection camera for this mirror
                const mirrorCamera = new THREE.PerspectiveCamera(
                    camera.fov,
                    camera.aspect,
                    camera.near,
                    camera.far
                );
                
                // Reflect camera position across mirror plane
                const cameraToMirror = mirrorPos.clone().sub(camera.position);
                const distance = cameraToMirror.dot(normal);
                mirrorCamera.position.copy(camera.position).add(normal.multiplyScalar(2 * distance));
                
                // Reflect camera direction
                const reflectedDirection = camera.getWorldDirection(new THREE.Vector3())
                    .reflect(normal.clone().negate());
                mirrorCamera.lookAt(
                    mirrorCamera.position.clone().add(reflectedDirection)
                );
                
                // Render scene from reflected camera to render target
                const renderTarget = mirrorRenderTargets[Math.min(mirrorIndex, mirrorRenderTargets.length - 1)];
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, mirrorCamera);
                renderer.setRenderTarget(null);
                
                // Apply reflection texture to mirror
                if (mirrorMesh.material) {
                    mirrorMesh.material.envMap = renderTarget.texture;
                    mirrorMesh.material.needsUpdate = true;
                }
            });
        }
        
        // Render loop with fractal mirror reflections
        function animate() {
            requestAnimationFrame(animate);
            updateMovement();
            controls.update();
            
            // Render recursive mirror reflections (creates fractal cascading effect)
            renderMirrorReflections();
            
            // Render main scene
            renderer.render(scene, camera);
            updateFPS();
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        });
        
        loadScene();
        animate();
    </script>
</body>
</html>

